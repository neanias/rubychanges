---
title: Ruby 3.3 changes
prev: /
next: 3.2
description: Ruby 3.3 full and annotated changelog
---

# Ruby 3.3

* **Released at:** Dec 25, 2023 ([NEWS.md](TODO) file)
* **Status (as of <<date>>):** TODO
* **This document first published:** TODO
* **Last change to this document:** <<date>>

<!--
* **Reason:**
* **Discussion:**
* **Documentation:**
* **Code:**
* **Notes:**
-->

### `Array#pack` and `String#unpack`: raise `ArgumentError` for unknown directives

* **Discussion:** [Bug #19150]
* **Documentation:** [doc/packed_data.rdoc](https://docs.ruby-lang.org/en/master/packed_data_rdoc.html)
* **Code:**
  ```ruby
  [1, 2, 3].pack('r*')
  # Ruby 3.1: "", no warning
  # Ruby 3.2: "", warning: unknown pack directive 'r' in 'r*'
  # Ruby 3.3: in `pack': unknown pack directive 'r' in 'r*' (ArgumentError)
  ```
* **Notes:**

### `Dir.for_fd` and `Dir.fchdir`

Two methods to accept an integer file descriptor as an argument: `for_fd` creates a `Dir` object from it; `fchdir` changes the current directory to one specified by a descriptor.

* **Reason:** New methods allow to use UNIX file descriptors if they are returned from a C-level code or obtained from OS.
* **Discussion:** [Feature #19347]
* **Documentation:** [Dir.for_fd](https://docs.ruby-lang.org/en/master/Dir.html#method-c-for_fd), [Dir.fchdir](https://docs.ruby-lang.org/en/master/Dir.html#method-c-fchdir)
* **Code:**
  ```ruby
  fileno = Dir.new('doc/').fileno
  # In reality, this #fileno might come from other library

  dir = Dir.for_fd(fileno)
  #=> #<Dir:0x00007f8831b810a8> -- no readable path representation
  dir.path #=> nil
  dir.to_a
  #=> ["forwardable.rd.ja", "packed_data.rdoc", "marshal.rdoc", "format_specifications.rdoc", ....
  # It was performed in the Ruby's core folder, and lists the doc/ contents

  # Attempt to use a bogus fileno will result in error:
  Dir.for_fd(0)
  # `for_fd': Not a directory - fdopendir (Errno::ENOTDIR)

  # Same with fileno that doesn't designate a directory:
  Dir.for_fd(Dir.new('README.md').fileno)
  # in `initialize': Not a directory @ dir_initialize - README.md (Errno::ENOTDIR)

  # Same logic works for .fchdir
  Dir.fchdir(fileno) #=> 0
  Dir.pwd
  #=> "/home/zverok/projects/ruby/doc" -- the current path have changed successfully

  # A block form of fchdir is available, like for a regular .chdir:
  Dir.fchdir(Dir.new('NEWS').fileno) do
    p Dir.pwd #=> "/home/zverok/projects/ruby/doc/NEWS"
  end
  Dir.pwd #=> "/home/zverok/projects/ruby/doc" -- back to the path before the block
  ```
* **Notes:**
  * The functionality is only supported on POSIX platforms;
  * The initial [ticket](https://bugs.ruby-lang.org/issues/19347) only proposed to find a way to be able to change a current directory to one specified by a descriptor (i.e., what eventually became `.fchdir`), but during the discussion a need were discovered for a generic instantiation of a `Dir` instance from the descriptor (what became `from_fd`), as well as a generic way to change the current directory to one specified by `Dir` instance ([`#chdir`](TODO), which is not related to descriptors but is generically useful).

### `Dir#chdir`

An instance method version of [Dir.chdir](https://docs.ruby-lang.org/en/master/Dir.html#method-c-chdir): changes the current working directory to one specified by the `Dir` instance.

* **Discussion:** [Feature #19347]
* **Documentation:** [Dir#chdir](https://docs.ruby-lang.org/en/master/Dir.html#method-i-chdir)
* **Code:**
  ```ruby
  Dir.pwd #=> "/home/zverok/projects/ruby"
  dir = Dir.new('doc')
  dir.chdir #=> nil
  Dir.pwd #=> "/home/zverok/projects/ruby/doc"

  # The block form works, too:
  Dir.new('NEWS').chdir do
    Dir.pwd #=> "/home/zverok/projects/ruby/doc/NEWS"
  end
  Dir.pwd #=> "/home/zverok/projects/ruby/doc"
  ```

### `MatchData#named_captures`: `symbolize_names:` argument

* **Discussion:** [Feature #19591]
* **Documentation:** [MatchData#named_captures](https://docs.ruby-lang.org/en/master/MatchData.html#method-i-named_captures)
* **Code:**
  ```ruby
  m = "2023-12-25".match(/(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/)
  m.named_captures
  #=> {"year"=>"2023", "month"=>"12", "day"=>"25"}
  m.named_captures(symbolize_names: true)
  #=> {:year=>"2023", :month=>"12", :day=>"25"}
  ```
* **Notes:** While `symbolize_names:` might looks somewhat strange (usually we talk about hash _keys_), it is done for consistency with Ruby standard library's [`JSON.parse`](https://docs.ruby-lang.org/en/master/JSON.html#module-JSON-label-Output+Options) signature, which inherited the terminology from the JSON specification.

### `Module#set_temporary_name`

Allows to assign a string to be rendered as class/module's `#name`, without assigning the class/module to a constant.

* **Reason:** The feature is useful to provide reasonable representation for dynamically auto-generated classes without assigning them to constants (which pollutes the global namespace and might conflict with existing constants) or redefining `Class#name` (which might break other code and not always respected in the output).
* **Discussion:** [Feature #19521]
* **Documentation:** [Module#set_temporary_name](https://docs.ruby-lang.org/en/master/Module.html#method-i-set_temporary_name)
* **Code:**
  ```ruby
dynamic_class = Class.new do
  def foo; end
end

dynamic_class.name #=> nil

# For dynamic classes, representation of related values is frequently unreadable:
dynamic_class #=> #<Class:0x0...>
instance = dynamic_class.new #=> #<#<Class:0x0...>:0x0...>
instance.method(:foo) #=> #<Method: #<Class:0x0...>#foo() ...>

dynamic_class::Nested = Module.new
dynamic_class::Nested #=> #<Class:0x0...>::Nested

# After assigning the temporary name, representation becomes more convenient:
dynamic_class.set_temporary_name("MyDSLClass(with description)")

dynamic_class #=> MyDSLClass(with description)
instance #=> #<MyDSLClass(with description):0x0...>
instance.method(:foo) #=> #<Method: MyDSLClass(with description)#foo() ...>

# Note that module constant names are assigned at the moment of their creation,
# and don't change when the temporary name is assigned:
dynamic_class::OtherNested = Module.new

dynamic_class::Nested #=> #<Class:0x0...>::Nested
dynamic_class::OtherNested #=> MyDSLClass(with description)::OtherNested

# Assigning names that correspond to constant name rules is prohibited:
dynamic_class.set_temporary_name("MyClass")
# `set_temporary_name': the temporary name must not be a constant path to avoid confusion (ArgumentError)
dynamic_class.set_temporary_name("MyClass::NestedName")
# `set_temporary_name': the temporary name must not be a constant path to avoid confusion (ArgumentError)

# When the module with a temporary name is put into a constant,
# it receives a permanent name, which can't be changed anymore
C = dynamic_class

# It affects all associated values (including modules)

dynamic_class #=> C
instance #=> #<C:0x0...>
instance.method(:foo) #=> #<Method: C#foo() ...>
dynamic_class::Nested #=> C::Nested
dynamic_class::OtherNested #=> C::OtherNested

dynamic_class.set_temporary_name("Can I have it back?")
# `set_temporary_name': can't change permanent name (RuntimeError)

# `nil` can be used to cleanup a temporary name:
other_class = Class.new
other_class.set_temporary_name("another one")
other_class #=> another one
other_class.set_temporary_name(nil)
other_class #=> #<Class:0x0...>
  ```
* **Notes:** Any phrase that used as a temporary name would be used verbatim; this might create very confusing `#inspect` results and error messages; so it is advised to use strings somehow implying that the name belong to a module. Imagine we wrap into classes with temporary names RSpec-style examples, and then there is a typo in such example:
  ```ruby
  it "works as a calculator" do
    expec(2+2).to eq 4
  end
  # If we assign just the example description as a temp.name, the
  # error would look like this:
  #
  #   undefined method `expec' for an instance of works as a calculator
  #                                               ^^^^^^^^^^^^^^^^^^^^^
  #
  # ...which is confusing. So it is probably better to construct a
  # module-like temporary name, to have:
  #
  #   undefined method `expec' for an instance of MyFramework::Example("works as a calculator")
  #                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  ```

### `ObjectSpace::WeakKeyMap`

A new "weak map" concept implementation. Unlike `ObjectSpace::WeakMap`, it compares keys by equality (`WeakMap` compares by identity), and only references to keys are weak (garbage-collectible).

* **Reason:** The idea of a new class grew out of increased usage of `ObjectSpace::WeakMap` (which was once considered internal). In many other languages, concept of "weak map" implies only key references are weak: this allows to use it as a generic "holder of some additional information related to a set of objects while they are alive," or just a weak set of objects (using them as keys and `true` as values): caches, deduplication sets, etc.
* **Discussion:** [Feature #18498]
* **Documentation:** [ObjectSpace::WeakKeyMap](https://docs.ruby-lang.org/en/master/ObjectSpace/WeakKeyMap.html)
* **Code:**
* **Notes:** The class interface is significantly leaner than `WeakMap`'s, and doesn't provide any kind of iteration methods (which is very hard to implement and use correctly with weakly-referenced objects), so the new class is more like a black box with associations than a collection.

### `ObjectSpace::WeakMap#delete`

* **Reason:** `WeakMap` is frequently used to have a loose list of objects that will need some processing at some point of program execution if they are still alive/used (that's why `WeekMap` and not `Array`/`Hash` is chosen in those cases). But it is possible that the code author wants to process objects conditionally, and to remove those which don't need processing anymoreâ€”even if they are still alive. `WeekMap` quacks like kind-of simple `Hash`, yet previously provided no way to delete keys.
* **Discussion:** [Feature #19561]
* **Documentation:** [ObjectSpace::WeakMap#delete](https://docs.ruby-lang.org/en/master/ObjectSpace/WeakMap.html#method-i-delete)
* **Code:**
  ```ruby
  files_to_close = ObjectSpace::WeakMap.new
  file1 = File.new('README.md')
  file2 = File.new('NEWS.md')

  files_to_close[file1] = true
  files_to_close[file2] = true

  files_to_close.delete(file1) #=> true

  # Attempt to delete non-existing key:
  files_to_close.delete(file1) #=> nil
  # An optional block can be provided in case the key doesn't exist:
  files_to_close.delete(file1) { puts "Already removed"; 0 }
  # Prints "Already removed", returns `0`

  # The block wouldn't be called if the deletion was effectful:
  files_to_close.delete(file2) { puts "Already removed"; 0 }
  # Prints nothing, returns true
  ```
* **Notes:**

### `Proc#dup` and `#clone` call `#initialize_dup` and `#initialize_copy`

* **Reason:** A fix for an old inconsistency: `Object`'s `#dup` and `#clone` methods docs
* **Discussion:** [Feature #19362]
* **Documentation:** â€” (Adheres to the behavior described for [Object#dup](https://docs.ruby-lang.org/en/master/Object.html#method-i-dup) and [#clone](https://docs.ruby-lang.org/en/master/Kernel.html#method-i-clone))
* **Code:**
  ```ruby
  # The examples would work the same with
  # #dup/#initialize_dup and #clone/#initialize_copy
  class TaggedProc < Proc
    attr_reader :tag

    def initialize(tag)
      super()
      @tag = tag
    end

    def initialize_dup(other)
      @tag = other.tag
      super
    end
  end

  proc = TaggedProc.new('admin') { }

  proc.tag #=> 'admin'
  proc.dup.tag
  # Ruby 3.2 => nil, the duplication didn't went through initialize_dup
  # Ruby 3.3 => "admin"
  ```
* **Notes:** Inheriting from core classes is an advanced technique, and most of the times there are simple ways to achieve same goals (like wrapper objects containing a `Proc` and an additional info).

### `Process.warmup`

* **Reason:**
* **Discussion:** [Feature #18885]
* **Documentation:** [Process.warmup](https://docs.ruby-lang.org/en/master/Process.html#method-c-warmup)
* **Code:**
* **Notes:**

### `Process::Status#&`  and `#>>` are deprecated

* **Reason:** These methods have been treating `Process::Status` as a very thin wrapper around an integer value of the return status of the process; which is unreasonable for supporting Ruby in more varying environments.
* **Discussion:** [Bug #19868]
* **Documentation:** [Process::Status#&](https://docs.ruby-lang.org/en/master/Process/Status.html#method-i-26), [#>>](https://docs.ruby-lang.org/en/master/Process/Status.html#method-i-3E-3E)
* **Code:**

### `Thread::Queue#freeze` and `SizedQueue#freeze` raise `TypeError`

* **Reason:** The discussion was started with a bug report about `Queue` not respecting `#freeze` in any way (`#push` and `#pop` were still working after `#freeze` call). It was then decided that allowing to freeze a queue like any other collection (leaving it immutable) would have questionable semantics: as `Queue` is meant to be an inter-thread communication utility, freezing a queue while some thread waits for it would either leave this thread hanging, or would require `#freeze`'s functionality to extend for communication with dependent threads. Neither is a good option, so the behavior of the method was changed to communicate that queue freezing doesn't make sense.
* **Discussion:** [Bug #17146]
* **Documentation:** [Thread::Queue#freeze](https://docs.ruby-lang.org/en/master/Thread/Queue.html#method-i-freeze) and [Thread::SizedQueue#freeze](https://docs.ruby-lang.org/en/master/Thread/SizedQueue.html#method-i-freeze)

### `Range#reverse_each`

Specialized `Range#reverse_each` method is implemented.

* **Reason:** Previously, `Range` didn't have a specialized `#reverse_each` method, so calling it would invoke a generic `Enumerable#reverse_each`. The latter works by  converting the object to array, and then enumerating this array. In case of a `Range` this can be inefficient (producing large arrays) or impossible (when only upper bound of the range is defined)
* **Discussion:** [Feature #18515]
* **Documentation:** [Range#reverse_each](https://docs.ruby-lang.org/en/master/Range.html#method-i-reverse_each)
* **Code:**
  ```ruby
  (1..2**100).reverse_each.take(3)
  # Ruby 3.2: hangs on my machine, trying to produce an array
  # Ruby 3.3: #=> [1267650600228229401496703205376, 1267650600228229401496703205375, 1267650600228229401496703205374]
  #  (returns immediately)

  (...5).reverse_each.take(3)
  # Ruby 3.2: can't iterate from NilClass (TypeError)
  # Ruby 3.3: #=> [5, 4, 3]

  (1...).reverse_each
  # Ruby 3.2: hangs forever, trying to produce an array
  # Ruby 3.3: `reverse_each': can't iterate from NilClass (TypeError)

  # The latter change affects any type of range beginning:
  ('a'...).reverse_each
  # Ruby 3.2: hangs forever, trying to produce an array
  # Ruby 3.3: `reverse_each': can't iterate from NilClass (TypeError)
  ```
* **Notes:** Other than raising `TypeError` for endless ranges (which works with any type of range beginning), the specialized behavior is only implemented for `Integer`. A possibility of a generalization was [discussed](https://bugs.ruby-lang.org/issues/18515#note-4) by using object's `#pred` method (opposite to `#succ`, which the range uses to iterate forward), but the scope of this change would be bigger, as currently only `Integer` implements such method. It is possible that the adjustments would be made in the future versions.

### `Refinement#refined_class` is renamed to `Refinement#target`

Just a renaming of the unfortunately named new method that [emerged in Ruby 3.2](/rubychanges/3.2.html#refinementrefined_class).

* **Discussion:** [Feature #19714]
* **Documentation:** [Refinement#target](https://docs.ruby-lang.org/en/master/Refinement.html#method-i-target)

### `String#bytesplice`: new arguments to select a portion of the replacement string

The low-level string manipulation method now allows to provide a coordinates of the part of the replacement string to be used.

* **Reason:** The new "byte-oriented" methods [were introduced](https://rubyreferences.github.io/rubychanges/3.2.html#byte-oriented-methods) in Ruby 3.2 to support low-level programming like text editors or network protocol implementations. In those use cases, the necessity of copying of a small part of one string into the middle of another is frequent, and producing intermediate strings (by first slicing the necessary part) is costly.
* **Discussion:** [Feature #19314]
* **Documentation:** [String#bytesplice](https://docs.ruby-lang.org/en/master/String.html#method-i-bytesplice)
* **Code:**
  ```ruby
  # Base usage
  'foo'.byteplice(1..2, 'bar', 0..1)
  # The receiver is modified

  # Or, alternatively:
  'foo'.byteplice(1, 2, 'bar', 0, 1)

  # Two forms can't be mixed:
  'foo'.byteplice(1..2, 'bar', 0, 1)
  # Semi-open ranges work:
  'foo'.byteplice(1..2, 'bar', 1..)
  'foo'.byteplice(1..2, 'bar', ..1)

  ```

### `TracePoint` supports `:rescue` event

Allows to trace when some exception was `rescue`'d in the code of interest.

* **Discussion:** [Feature #19572]
* **Documentation:** [TracePoint#Events](https://docs.ruby-lang.org/en/master/TracePoint.html#class-TracePoint-label-Events)
* **Code:**
  ```ruby
  TracePoint.trace(:rescue) do |tp|
    puts "Exception rescued: #{tp.raised_exception.inspect} at #{tp.path}:#{tp.lineno}"
  end

  begin
    raise "foo"
  rescue => e
  end
  # Prints: "Exception rescued: #<RuntimeError: foo> at example.rb:7
  ```
* **Notes:** The event-specific attribute for the event is the same as for `:raise`: [#raised_exception](https://docs.ruby-lang.org/en/master/TracePoint.html#method-i-raised_exception).

### `Kernel#lambda` raises when passed `Proc` instance

* **Reason:** `lambda`'s goal is to create a lambda from provided literal block; in Ruby, it is impossible to change the "lambdiness" of the block once it is created. But `lambda(&proc_instance)` never notified users of that, which was confusing.
* **Discussion:** [Feature #19777]
* **Documentation:** [Kernel#lambda](https://docs.ruby-lang.org/en/master/Kernel.html#method-i-lambda) _(no specific details are provided, though)_
* **Code:**
  ```ruby
  # Intended usage:
  l = lambda { |a, b| a + b }
  l.lambda? #=> true
  l.parameters #=> [[:req, :a], [:req, :b]]

  # Unintended usage:
  p = proc { |a, b| a + b }

  # In Ruby 3.2 and below, it worked, but the produced value wasn't lambda:
  l = lambda(&p)
  l.parameters #=> [[:opt, :a], [:opt, :b]]
  l.lambda? #=> false
  l.object_id == p.object_id #=> true, it is just the same proc

  # Ruby 3.3:
  l = lambda(&p)
  # in `lambda': the lambda method requires a literal block (ArgumentError)

  # Despite the message about a "literal block," the method
  # works (though has no meaningful effect) with lambda-like Proc objects
  other_lambda = lambda { |a, b| a + b }
  lambda(&other_lambda) #=> works
  lambda(&:to_s) #=> works
  lambda(&method(:puts)) #=> works
  ```
* **Notes:**
  * The discussion was once [started](https://bugs.ruby-lang.org/issues/15973) from the proposal to make `lambda` change "lambiness" of a passed block, but it raises multiple issues (changing the block semantics mid-program is just one of them). In general, `lambda` as a _method_ is considered legacy, inferior to the `-> { }` lambda literal syntax, exactly due to problems like this: it looks like a regular method that receives a block, and therefore should be able accept _any_ block, but in fact it is "special" method. So in 3.0, there was a warning about `lambda(&proc_instance)`, and since 3.3, the warning finally turned into an error.
  * There is exactly one occurrence in Ruby where block semantics _changes_ mid-flight:

### Deprecate subprocess creation with method dedicated to files

* **Reason:**
* **Discussion:** [Feature #19630]
* **Documentation:**
* **Affected methods:**
  * Kernel#open
  * URI.open
  * IO.binread
  * IO.foreach
  * IO.readlines
  * IO.read
  * IO.write
* **Code:**
* **Notes:**

### New `Warning` category: `:performance`

* **Reason:**
* **Discussion:** [Feature #19538]
* **Documentation:** [Warning#[category]](https://docs.ruby-lang.org/en/master/Warning.html#method-c-5B-5D)
* **Code:**
* **Notes:**

### `Fiber#kill`

Terminates the Fiber by sending an exception inside it.

* **Reason:** The method is intended to be used to fibers that represent processes that need to be told explicitly to finalize themselves (invoking any `ensure` operations and cleanups that are necessary). If such fiber just abandoned and collected by a GC, it wouldn't invoke fiber's `ensure`, and therefore the resources wouldn't be cleaned; so there was need for a way to do this explicitly.
* **Discussion:** [Bug #595]
* **Documentation:** [Fiber#kill](https://docs.ruby-lang.org/en/master/Fiber.html#method-i-kill)
* **Code:**
  ```ruby

  # Semi-realistic usage example:
  reader = Fiber.new do
    conn = SomeConnection.open(**params)
    while conn.open?
      Fiber.yield conn.read
    end
  ensure
    conn.close
  end

  headers = reader.resume # reads something from the connection
  body_line1 = reader.resume # reads some more
  # Now, if we want to explicitly stop reading and be sure that the connection
  # is closed, we might do this:
  reader.kill # invokes #ensure
  ```
* **Notes:**

### `Encoding#replicate` is removed

* **Reason:**
* **Discussion:** [Feature #18949]
* **Documentation:** â€”
* **Code:**
* **Notes:**

 added for checking if two ranges overlap. [[Feature #19839]]

### `Range#overlap?`

Checks for overlapping of two ranges.

* **Discussion:** [Feature #19839]
* **Documentation:** [Range#overlap?](https://docs.ruby-lang.org/en/master/Range.html#method-i-overlap-3F)
* **Code:**
  ```ruby
  (1..3).overlap?(2..5) #=> true
  (1..3).overlap?(4..5) #=> false
  (..3).overlap?(3..)   #=> true

  (1...3).overlap?(3..5)
  #=> false, the first range doesn't include 3
  (1..3).overlap?(3...3)
  #=> false, the second range is empty (note it has an exclusive end)

  (1..3).overlap?('a'..'c')
  #=> false, ranges are incompatible (but not an exception)
  (1..3).overlap?(1)
  # `overlap?': wrong argument type Integer (expected Range) (TypeError)
  ```
* **Notes:** As documentation points out, the _technically empty_ `(...-Float::INFINITY)` range (nothing can be lower than `Float::INFINITY`, and it is not included) still considered overlapping with itself by this method:
  ```ruby
  (...-Float::INFINITY).overlap?(...-Float::INFINITY) #=> true
  # Same with other "nothing could be smaller" ranges:
  (..."").overlap?(..."") #=> true
  ```
  (Though, with Ruby's dynamic nature, one _technically can_ define an object that will report itself to be smaller than an empty string, and therefore belong to a range... Making it non-empty.)

### Standalone `it` in blocks will become anonymous argument in Ruby 3.4

In Ruby 3.3, it will just warn to prepare for a change.

* **Reason:** Numeric designation for anonymous bloc arguments (`_1`, `_2`, and so on) were considered ugly by many people, so after years of discussion, the `it` keyword is to be introduced on the next Ruby version; for now, it just warns _in places where it would be considered an anonymous block argument_.
* **Discussion:** [Feature #18980]
* **Code:** In the code below, where Ruby 3.3 currently produces a warning, Ruby 3.4 would treat `it` as an anonymous block argument; where Ruby 3.3 doesn't produce a warning, Ruby 3.4 would treat `it` as a local variable name or a method call (and would look for such names available in the scope).
  ```ruby
  # The cases that are warned:
  # warning: `it` calls without arguments will refer to the first block param in Ruby 3.4; use it() or self.it

  (1..3).map { it }      # inside a block without explicit parameters
  (1..3).map { it; _1 }  # ...even if numbered parameters are used, too
  def it; end
  (1..3).map { it }      # even if a method with name `it` exists in the scope

  # The cases that are not warned:

  it                        # not inside a block
  (1..3).map { |x| it }     # inside a block with named parameters
  (1..3).map { || it }      # ...even if they are empty
  (1..3).map { it() }       # with parentheses
  (1..3).map { it {} }      # with a block attached
  (1..3).map { it = 5; it } # if a local variable with the same name is created in the block
  it = 5
  (1..3).map { it }         # if a local variable with the same name is in the scope
  ```
* **Notes:** The new feature isn't expected to conflict with RSpec's [`it`](https://rspec.info/documentation/3.12/rspec-core/RSpec/Core/ExampleGroup.html#it-class_method), as calling that without any block attached is useless.
